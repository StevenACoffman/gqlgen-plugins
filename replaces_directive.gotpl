{{/* NOTE(benkraft): gqlgen's template functions aren't the best documented;
     these are the ones we use:
     - reserveImport: import the given file, ensuring it will not be aliased
       (such that we can just refer to, say, "context.Context" below).
     - lookupImport: import the given file, and return the alias under which
       it will be imported (better for importing user code which may have
       bad package names).
     - ref: given a go/types.Type, return the Go code to refer to it
       (may call lookupImport).
     - go: given an identifier, turn it into a Go-style CamelCase name.
     These are listed in gqlgen's codegen/templates.Funcs.
     TODO(benkraft): put this documentation somewhere in upstream. */}}
{{ reserveImport "reflect" }}
{{ reserveImport "github.com/StevenACoffman/simplerr/errors" }}

{{ range .Objects }}
// This function is auto-generated by gqlgen and maps {{ .NewGoName }} structs
// to deprecated {{ .OldGoName }} structs. Note that all fields in the object
// struct are mapped even though some fields may have resolvers. That's okay
// since the mapping is a no-op in that case.
func Map{{ .NewGoName }}To{{ .OldGoName }}(source *{{ .NewGoName }}) *{{ .OldGoName }} {
  if source == nil {
    return nil
  }
  return &{{ .OldGoName }}{
    {{ range .Fields }}{{ . }}: source.{{ . }},
    {{ end }}
  }
}

// This function is auto-generated by gqlgen and maps deprecated
// {{ .OldGoName }} structs to {{ .NewGoName }} structs. Note that all fields
// in the object struct are mapped even though some fields may have resolvers.
// That's okay since the mapping is a no-op in that case.
func Map{{ .OldGoName }}To{{ .NewGoName }}(source *{{ .OldGoName }}) *{{ .NewGoName }} {
  if source == nil {
    return nil
  }
  return &{{ .NewGoName }}{
    {{ range .Fields }}{{ . }}: source.{{ . }},
    {{ end }}
  }
}
{{ end }}

{{ range .InputObjects }}
// This function is auto-generated by gqlgen and maps renamed fields on the
// input type according to @replaces directives present on the fields in the
// schema. It validates that either exactly one or at most one of the
// renamed/deprecated fields is present in the input type (depending on the
// wasRequiredBeforeRename argument on the directive) and populates the field
// corresponding to the new name on the input object. The deprecated field is
// set to nil.
func ValidateAndRename{{ .Name }}(input *{{ .Name }}) error {
  if input == nil {
    return nil
  }
  {{ range .Fields }}
  // Handle {{ .OldGoName }} -> {{ .NewGoName }}
  {
    new := input.{{ .NewGoName }}
    old := input.{{ .OldGoName }}

    {{ if .TreatZeroAsUnset }}
    newIsSet := new != nil && !reflect.ValueOf(*new).IsZero()
    oldIsSet := old != nil && !reflect.ValueOf(*old).IsZero()
    {{ else }}
    newIsSet := new != nil
    oldIsSet := old != nil
    {{ end }}

    {{ if .WasRequiredBeforeRename }}
    if !newIsSet && !oldIsSet {
      return errors.InvalidInput(
        "exactly one of these input fields must be set (neither set)",
        errors.Fields{
          "fieldName": "{{ .NewName }}",
          "deprecatedFieldName": "{{ .OldName }}",
        },
      )
    }
    {{ end }}
    if newIsSet && oldIsSet {
      return errors.InvalidInput(
        {{ if .WasRequiredBeforeRename }}
        "exactly one of these input fields must be set (both set)",
        {{ else }}
        "at most one of these input fields must be set (both set)",
        {{ end }}
        errors.Fields{
          "fieldName": "{{ .NewName }}",
          "deprecatedFieldName": "{{ .OldName }}",
        },
      )
    }
    if newIsSet {
      input.{{ .NewGoName }} = new
    } else {
      input.{{ .NewGoName }} = old
    }
    input.{{ .OldGoName }} = nil
  }
  {{ end }}
  return nil
}
{{ end }}
